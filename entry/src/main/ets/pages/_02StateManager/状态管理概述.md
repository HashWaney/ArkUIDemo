### 状态管理机制
在声明式UI编程框架中,UI是程序状态的运行结果,用户构建了一个UI模型,其中应用的运行时的状态是参数。
//言外之意：数据驱动UI
当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。

### 什么是状态变量？
变量必须被装饰器装饰才能成为状态变量，状态变量的改变会引起UI的渲染刷新，如果不使用状态变量，UI只能在初始化时渲染，后续将不再刷新。

### 基本概念

状态变量：被状态装饰器修饰的变量，状态变量值的改变会引起UI的渲染更新
@State num:number =1
其中@State是状态装饰器，num是状态变量

常规变量：没有被状态修饰的变量，通过应用于辅助计算，它的改变永远不会引起UI的刷新，

数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据，通常意义为父组件传给子组件的数据。

命名参数机制：父组件通过指定参数传递子组件的状态变量，为父子传递同步参数的主要手段：CompA({aProp:this.aProp})

从父组件初始化：父组件使用命名参数机制，将指定参数传递给子组件，子组件初始化的默认值在有父组件传值的情况下，会被覆盖。

@Component
struct MyComponent{
    @State count:number =0;
    private increaseBy:number =1;
    build(){
    }
}
@Entry
@Component
struct Parent{
    build(){
        Column(){   
            // 从父组件初始化，覆盖本地定义的默认值
            MyComponent({count:1,increaseBy:2})
        }
    }
}
初始化子组件：父组件中状态变量可以传递给子组件，初始化子组件对应的状态变量。

本地初始化：在变量声明的时候赋值，作为变量的默认值。

### 装饰器组成：
1、管理组件拥有状态的装饰器：
    组件级别的状态管理，可以观察组件内变化，和不同组件层级的变化
    但是需要唯一观察同一个组件树上，即同一个页面内。
2、管理应用拥有状态的装饰器：
    应用级别的状态管理，可以观察不同页面，甚至不同UIAbility的状态变化，
    是应用内全局的状态管理。
从数据的传递形式和同步类型层面看，也可以分为
- 只读的单向传递
- 可变更的双向传递 


